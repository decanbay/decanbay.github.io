<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deniz Ekin Canbay - DEM Physics Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.8;
            overflow-x: hidden;
            user-select: none; /* Improve interaction feel */
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 100%);
            touch-action: none; /* Prevent scrolling on mobile while touching canvas */
        }

        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            z-index: 1000;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        nav a {
            color: #e0e0e0;
            text-decoration: none;
            font-size: 1.1rem;
            transition: color 0.3s;
            position: relative;
            cursor: pointer;
        }

        nav a:hover {
            color: #4a9eff;
        }

        nav a::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background: #4a9eff;
            transition: width 0.3s;
        }

        nav a:hover::after, nav a.active::after {
            width: 100%;
        }

        nav a.active {
            color: #4a9eff;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 100px 40px 60px;
            pointer-events: none; /* Let clicks pass through to canvas where empty */
        }
        
        /* Re-enable pointer events for content */
        .content-box, .project-card, .footer {
            pointer-events: auto;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .header h1 {
            font-size: 3rem;
            color: #4a9eff;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.3);
            margin-bottom: 1rem;
        }

        .header p {
            font-size: 1.3rem;
            color: #b0b0b0;
        }

        .project-card {
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem auto;
            max-width: 800px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s;
        }
        
        .project-card:hover {
            transform: translateY(-5px);
            border-color: rgba(74, 158, 255, 0.5);
        }

        .project-card h2 {
            color: #4a9eff;
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        .content-box {
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 3rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        h1 {
            text-align: center;
            font-size: 2.8rem;
            margin-bottom: 2rem;
            color: #4a9eff;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.3);
        }

        h2 {
            font-size: 2rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #6bb6ff;
        }

        p {
            margin-bottom: 1.5rem;
            text-align: justify;
            font-size: 1.1rem;
        }

        .footer {
            text-align: center;
            padding: 2rem;
            font-size: 1.2rem;
            color: #4a9eff;
            font-weight: 500;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 1rem 1.5rem;
            border-radius: 10px;
            border: 1px solid rgba(74, 158, 255, 0.3);
            z-index: 1000;
            font-size: 0.9rem;
            color: #b0b0b0;
            pointer-events: none;
        }

        .instructions strong {
            color: #4a9eff;
        }
        
        /* Stats counter for nerdy details */
        #stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #4a9eff;
            font-family: 'Segoe UI', monospace;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>
    
    <div id="stats"></div>

    <nav>
        <ul>
            <li><a data-page="home">Home</a></li>
            <li><a data-page="portfolio">Portfolio</a></li>
        </ul>
    </nav>

    <div class="container" id="app-container">
        <!-- Content loaded via JS -->
    </div>

    <div class="instructions">
        <strong>Mouse</strong> Repel/Attract<br>
        <strong>Left Click</strong> Attract<br>
        <strong>Right Click</strong> Spawn (Hold)<br>
    </div>

    <!-- APPLICATION LOGIC -->
    <script>
        // --- ROUTER (App.js Logic) ---
        const App = (function() {
            const pages = {
                home: `
                    <div class="content-box">
                        <h1>Recipe for Red Pill</h1>
                        <p>Human consciousness and our inner experiences arise from complex biological information processing systems, like computer programs. Much like artificial intelligence, human consciousness does not exist beyond the material or physical realm. Our perception of an autonomous self, free will, and profound inner life is an evolutionary construct, a sophisticated illusion created by neural 'software' following genetic and memetic 'programming'.</p>
                        <p>From a cosmic perspective, nothing we think, feel, or experience truly 'matters'; these concepts of meaning, significance, and agency are compelling yet illusory constructs arising from biology, chemistry, and ultimately physics, rather than from any deeper transcendence. This situation presents a paradox: our apparent ability to rationally ponder and 'decide' is undermined by the determinism that precludes true free choices outside the physical truth of cause-and-effect. Even the conclusions questioning free will are themselves deterministic outputs.</p>

                        <h2>The Drive to Find Meaning</h2>
                        <p>Why do we have this drive to find meaning? It is simply a survival instinct. But why do we want to survive then, in the grand scheme of things, isn't it insignificant? Yes, it is. This drive is simply an undirected consequence of physical laws. Analogous to molecules forming stable conformations, early replicating molecular patterns that persisted and propagated were favoured by these laws, without any inherent intent. They did not 'want' to survive; they just did because of physics, not very different than interacting magnets. Some molecule combinations are more stable, and some combinations of these combinations are even more stable, and so on. The apparent drive towards complexity emerges as a natural consequence of physicochemical systems. This is what creates everything including us. Life is a blind, replicative force shaped by physical forces rather than foresight.</p>
                        <p>It is like a virus of physical laws, emerging from the chaos of the universe as certain chemicals and their combinations favour each other. We are a byproduct of the universe's laws. Ultimately, nothing we experience truly 'matters' outside the deterministic chain of physical causality. Emotions, ideals, and perceived choices are appealing ultimately serving to physics without cosmic transcendence.</p>
                        <p>Yet, even this revelation is just another domino in the chain of causality, highlighting the harsh reality of our existence, which I find humour and sorrow in its self-deprecation.</p>
                        <p>Choosing to live despite knowing this is showing respect to the physics which itself does not but is matter, literally.</p>
                    </div>

                    <div class="footer">
                        Deniz Ekin Canbay
                    </div>
                `,
                portfolio: `
                    <div class="header">
                        <h1>Portfolio</h1>
                        <p>My Projects & Work</p>
                    </div>
                    <div class="project-card">
                        <h2>Coming Soon</h2>
                        <p>New projects and updates are on the way. Check back soon!</p>
                    </div>
                    <div class="footer">
                        Deniz Ekin Canbay
                    </div>
                `
            };

            function navigate(page) {
                const container = document.getElementById('app-container');
                if (!container) return;

                // Fade out effect could go here, but strict DOM replacement is faster
                container.innerHTML = pages[page] || pages.home;

                document.querySelectorAll('nav a').forEach(link => {
                    link.classList.remove('active');
                    if (link.dataset.page === page) {
                        link.classList.add('active');
                    }
                });

                const titles = {
                    home: 'Deniz Ekin Canbay - A Harsh Reality',
                    portfolio: 'Deniz Ekin Canbay - Portfolio'
                };
                document.title = titles[page] || titles.home;
            }

            function setupNavigation() {
                document.querySelectorAll('nav a').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const page = link.dataset.page;
                        navigate(page);
                        // Use pushState to manage URL
                        // Note: inside an iframe/preview, pushState might behave differently
                        try {
                            history.pushState({ page }, '', `#${page}`);
                        } catch(e) {}
                    });
                });

                window.addEventListener('popstate', (e) => {
                    const page = e.state?.page || 'home';
                    navigate(page);
                });
            }

            function init() {
                // Check hash for initial page to support refresh in simple static hosting
                const hash = window.location.hash.replace('#', '');
                let initialPage = hash || 'home';
                if (!pages[initialPage]) initialPage = 'home';
                
                setupNavigation();
                navigate(initialPage);
            }

            return { init };
        })();

        // --- DEM PARTICLE ENGINE (New Logic) ---
        const ParticleSystem = (function() {
            let canvas, ctx;
            let width, height;
            let particles = [];
            
            // Physics Constants
            const MAX_PARTICLES = 1800; 
            const GRAVITY = 0.15;
            const FRICTION = 0.99; // Air resistance
            const WALL_DAMPING = 0.6; // Bounciness against walls
            const RESTITUTION = 0.4; // Reduced: Particles lose more energy on collision (0.8 -> 0.4)
            const MOUSE_RADIUS = 250;
            const GRID_SIZE = 20;

            let mouse = { x: -1000, y: -1000, leftDown: false, rightDown: false };
            let grid = []; 
            let cols = 0;
            
            // Perf monitoring
            let lastTime = 0;
            const statsEl = document.getElementById('stats');

            class Particle {
                constructor(x, y, vx, vy) {
                    this.x = x;
                    this.y = y;
                    this.vx = vx;
                    this.vy = vy;
                    this.radius = Math.random() * 4 + 3; // Variable size
                    this.mass = this.radius; // Mass proportional to size
                    this.alpha = Math.random() * 0.5 + 0.5;
                    this.color = 'blue'; // Placeholder, updated every frame
                }

                update() {
                    // Apply Gravity
                    this.vy += GRAVITY;

                    // Apply Mouse Forces
                    const dx = this.x - mouse.x;
                    const dy = this.y - mouse.y;
                    const distSq = dx*dx + dy*dy;
                    
                    if (distSq < MOUSE_RADIUS * MOUSE_RADIUS && !mouse.rightDown) {
                        const dist = Math.sqrt(distSq);
                        const force = (MOUSE_RADIUS - dist) / MOUSE_RADIUS;
                        const angle = Math.atan2(dy, dx);
                        
                        // If left pressed: Attract, Else: Repel
                        const dir = mouse.leftDown ? 1 : -1;
                        const strength = mouse.leftDown ? 2 : 15;
                        
                        this.vx += Math.cos(angle) * force * strength * dir;
                        this.vy += Math.sin(angle) * force * strength * dir;
                    }

                    // Update Position
                    this.x += this.vx;
                    this.y += this.vy;

                    // Friction
                    this.vx *= FRICTION;
                    this.vy *= FRICTION;

                    // Boundary Constraints
                    this.constrain();
                    
                    // --- DYNAMIC COLOR LOGIC (Momentum -> Color) ---
                    const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                    const momentum = speed * this.mass; // p = mv
                    
                    let r, g, b;

                    // Mapping Momentum to Color: Blue -> Red -> White
                    // Thresholds: 0-15 (Blue to Red), 15-30+ (Red to White)
                    
                    if (momentum < 15) {
                        // Blue (0, 100, 255) -> Red (255, 50, 0)
                        const t = momentum / 15;
                        r = 0 + (255 - 0) * t;
                        g = 100 + (50 - 100) * t;
                        b = 255 + (0 - 255) * t;
                    } else {
                        // Red (255, 50, 0) -> White (255, 255, 255)
                        const t = Math.min((momentum - 15) / 25, 1);
                        r = 255;
                        g = 50 + (255 - 50) * t;
                        b = 0 + (255 - 0) * t;
                    }

                    this.color = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, ${this.alpha})`;
                }

                constrain() {
                    // Floor
                    if (this.y + this.radius > height) {
                        this.y = height - this.radius;
                        this.vy *= -WALL_DAMPING;
                        this.vx *= 0.95; // Floor friction
                    } 
                    // Ceiling
                    else if (this.y - this.radius < 0) {
                        this.y = this.radius;
                        this.vy *= -WALL_DAMPING;
                    }

                    // Walls
                    if (this.x + this.radius > width) {
                        this.x = width - this.radius;
                        this.vx *= -WALL_DAMPING;
                    } else if (this.x - this.radius < 0) {
                        this.x = this.radius;
                        this.vx *= -WALL_DAMPING;
                    }
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }

            // --- SPATIAL PARTITIONING & COLLISION RESOLUTION ---
            
            function updateGrid() {
                // Clear grid
                grid = new Array(cols * Math.ceil(height / GRID_SIZE)).fill(null).map(() => []);
                
                // Populate grid
                for (let p of particles) {
                    // Determine which cell the particle is in
                    const col = Math.floor(p.x / GRID_SIZE);
                    const row = Math.floor(p.y / GRID_SIZE);
                    const index = row * cols + col;
                    
                    if (grid[index]) {
                        grid[index].push(p);
                    }
                }
            }

            function resolveCollisions() {
                // For each cell in the grid
                for (let i = 0; i < grid.length; i++) {
                    const cell = grid[i];
                    if (!cell || cell.length === 0) continue;

                    // Get neighbor cells (including current) to check for collisions
                    // We only need to check current, right, bottom-left, bottom, bottom-right
                    // to avoid double checks and cover all pairs.
                    const neighbors = getNeighborCells(i);

                    for (let p1 of cell) {
                        for (let nIndex of neighbors) {
                            if (!grid[nIndex]) continue;
                            
                            for (let p2 of grid[nIndex]) {
                                if (p1 === p2) continue;
                                
                                // Optimization: Simple bounding box check before sqrt
                                if (Math.abs(p1.x - p2.x) > p1.radius + p2.radius) continue;
                                if (Math.abs(p1.y - p2.y) > p1.radius + p2.radius) continue;

                                const dx = p2.x - p1.x;
                                const dy = p2.y - p1.y;
                                const distSq = dx*dx + dy*dy;
                                const minDist = p1.radius + p2.radius;

                                if (distSq < minDist * minDist && distSq > 0) {
                                    const dist = Math.sqrt(distSq);
                                    const overlap = (minDist - dist) / 2;
                                    
                                    // Normal vector
                                    const nx = dx / dist;
                                    const ny = dy / dist;

                                    // Separate particles (Position Correction)
                                    p1.x -= nx * overlap;
                                    p1.y -= ny * overlap;
                                    p2.x += nx * overlap;
                                    p2.y += ny * overlap;

                                    // Relative Velocity
                                    const rvx = p2.vx - p1.vx;
                                    const rvy = p2.vy - p1.vy;
                                    
                                    // Velocity along normal
                                    const velAlongNormal = rvx * nx + rvy * ny;

                                    // Do not resolve if moving apart
                                    if (velAlongNormal > 0) continue;

                                    // Impulse Scalar
                                    let j = -(1 + RESTITUTION) * velAlongNormal;
                                    j /= (1/p1.mass + 1/p2.mass);

                                    // Apply impulse
                                    const impulseX = j * nx;
                                    const impulseY = j * ny;

                                    p1.vx -= impulseX / p1.mass;
                                    p1.vy -= impulseY / p1.mass;
                                    p2.vx += impulseX / p2.mass;
                                    p2.vy += impulseY / p2.mass;
                                }
                            }
                        }
                    }
                }
            }

            function getNeighborCells(index) {
                const neighbors = [index];
                const r = Math.floor(index / cols);
                const c = index % cols;

                // Right
                if (c < cols - 1) neighbors.push(index + 1);
                
                // Bottom row
                const bottomIndex = index + cols;
                if (bottomIndex < grid.length) {
                    neighbors.push(bottomIndex); // Bottom
                    if (c > 0) neighbors.push(bottomIndex - 1); // Bottom Left
                    if (c < cols - 1) neighbors.push(bottomIndex + 1); // Bottom Right
                }
                
                return neighbors;
            }

            function spawnParticles(x, y, count, explode = false) {
                for (let i = 0; i < count; i++) {
                    if (particles.length >= MAX_PARTICLES) particles.shift(); // Remove oldest if limit reached

                    const angle = Math.random() * Math.PI * 2;
                    // Explosion is faster, normal spawn is slower/dripping
                    const speed = explode ? (Math.random() * 10 + 5) : (Math.random() * 2); 
                    
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    
                    // Add small random offset to position so they don't spawn inside each other perfectly
                    const offsetX = (Math.random() - 0.5) * 10;
                    const offsetY = (Math.random() - 0.5) * 10;

                    particles.push(new Particle(x + offsetX, y + offsetY, vx, vy));
                }
            }

            function resize() {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                
                // Recalculate grid columns based on new width
                cols = Math.ceil(width / GRID_SIZE);
            }

            function animate(timestamp) {
                // Clear Canvas with trail effect
                ctx.fillStyle = 'rgba(10, 10, 10, 0.4)'; // Slightly higher opacity to clear faster for crisp physics
                ctx.fillRect(0, 0, width, height);

                // Update Grid
                updateGrid();

                // Solve Physics
                resolveCollisions();
                
                // Update & Draw Particles
                for (let p of particles) {
                    p.update();
                    p.draw();
                }

                // Interaction: Continuous spawn if right mouse held
                if (mouse.rightDown) {
                    spawnParticles(mouse.x, mouse.y, 3, false);
                }

                // Debug stats
                if (timestamp - lastTime > 200) {
                    statsEl.innerHTML = `Particles: <span style="color: #fff">${particles.length}</span>`;
                    lastTime = timestamp;
                }

                requestAnimationFrame(animate);
            }

            function init(canvasId) {
                canvas = document.getElementById(canvasId);
                ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on canvas background
                
                resize();
                window.addEventListener('resize', resize);

                // Initial burst
                spawnParticles(width/2, height/3, 400, true);

                // Mouse Events
                window.addEventListener('mousemove', e => {
                    mouse.x = e.clientX;
                    mouse.y = e.clientY;
                });
                
                window.addEventListener('mousedown', e => {
                    mouse.x = e.clientX;
                    mouse.y = e.clientY;
                    if (e.button === 0) mouse.leftDown = true;
                    if (e.button === 2) mouse.rightDown = true;
                });

                window.addEventListener('mouseup', (e) => {
                    if (e.button === 0) mouse.leftDown = false;
                    if (e.button === 2) mouse.rightDown = false;
                });
                
                window.addEventListener('contextmenu', e => e.preventDefault());

                // Touch support
                canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    mouse.x = e.touches[0].clientX;
                    mouse.y = e.touches[0].clientY;
                    mouse.isPressed = true;
                }, {passive: false});

                canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    mouse.x = e.touches[0].clientX;
                    mouse.y = e.touches[0].clientY;
                }, {passive: false});

                canvas.addEventListener('touchend', () => mouse.isPressed = false);

                animate(0);
            }

            return { init };
        })();

        // Start everything
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
            ParticleSystem.init('particle-canvas');
        });
    </script>
</body>
</html>